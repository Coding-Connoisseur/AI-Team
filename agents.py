import os
import subprocess
import sqlite3
import logging

class BaseAgent:
    def __init__(self, name, knowledge_base):
        self.name = name
        self.knowledge_base = knowledge_base
        self.memory = {}

    def can_handle(self, task):
        raise NotImplementedError

    def execute_task(self, task):
        raise NotImplementedError

    def learn(self, task, outcome):
        if task not in self.memory:
            self.memory[task] = {"successes": 0, "failures": 0}
        
        if outcome == "success":
            self.memory[task]["successes"] += 1
        else:
            self.memory[task]["failures"] += 1

        print(f"{self.name} has learned from task {task}. Successes: {self.memory[task]['successes']}, Failures: {self.memory[task]['failures']}")

    def adjust_behavior(self, task):
        if task in self.memory and self.memory[task]["failures"] > self.memory[task]["successes"]:
            print(f"{self.name} adjusting behavior for task {task}")

class ProjectArchitectAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Project Architect AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "architecture design"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is creating the project architecture...")
        
        # Real-world action: Create directories and files on the disk
        project_structure = {
            "src": {
                "main.py": "# Main entry point",
                "utils.py": "# Utility functions",
                "tests": {
                    "test_main.py": "# Test cases for main"
                }
            },
            "docs": {
                "README.md": "# Project documentation"
            }
        }
        base_path = "./real_project"  # Base path for the project
        
        # Create directories and files
        for folder, contents in project_structure.items():
            folder_path = os.path.join(base_path, folder)
            os.makedirs(folder_path, exist_ok=True)
            
            for file_name, file_content in contents.items():
                if isinstance(file_content, dict):  # It's a subdirectory
                    subdir_path = os.path.join(folder_path, file_name)
                    os.makedirs(subdir_path, exist_ok=True)
                    for subfile_name, subfile_content in file_content.items():
                        with open(os.path.join(subdir_path, subfile_name), 'w') as f:
                            f.write(subfile_content)
                else:
                    with open(os.path.join(folder_path, file_name), 'w') as f:
                        f.write(file_content)
        
        print(f"Real-world project structure created by {self.name}.")
        self.learn(task, "success")
        return "success"

class CodeGeneratorAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Code Generator AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "code generation"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is generating real code...")
        
        # Generate real code and write it to a file
        base_path = "./real_project/src/"
        code_snippet = '''
            def main():
                print("Hello, World!")

            if __name__ == "__main__":
                main()
            '''
        with open(os.path.join(base_path, "main.py"), 'w') as f:
            f.write(code_snippet)
        
        print(f"Code generated by {self.name} and written to main.py.")
        self.learn(task, "success")
        return "success"

class TestAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Test AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "testing"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is running real tests...")
        
        # Assume we're using unittest for Python tests
        result = subprocess.run(["python3", "-m", "unittest", "discover", "./real_project/src/tests"], capture_output=True)
        
        if result.returncode == 0:
            print("All tests passed.")
            self.learn(task, "success")
            return "success"
        else:
            print(f"Tests failed:\n{result.stderr.decode()}")
            self.learn(task, "failure")
            return "failure"

class EnhancerAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Enhancer AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "enhancement"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is enhancing the project...")
        
        # Real-world enhancement: Add a new feature to the code
        base_path = "./real_project/src/"
        enhancement_snippet = '''
            def new_feature():
                print("This is a new feature!")
            '''
        with open(os.path.join(base_path, "utils.py"), 'a') as f:
            f.write(enhancement_snippet)
        
        print(f"Enhancement added to utils.py by {self.name}.")
        self.learn(task, "success")
        return "success"

class DocumentationAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Documentation AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "documentation"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is generating project documentation...")
        
        # Real-world documentation creation: Writing README.md
        base_path = "./real_project/docs/"
        documentation_content = """
        # Project Documentation

        ## Overview
        This project contains the following:

        - `src/main.py`: The main entry point.
        - `src/utils.py`: Utility functions.
        - `src/tests/test_main.py`: Unit tests for the project.

        ## How to Run
        1. Install dependencies: `pip install -r requirements.txt`
        2. Run the application: `python main.py`
        3. Run the tests: `python -m unittest discover src/tests`
        """
        with open(os.path.join(base_path, "README.md"), 'w') as f:
            f.write(documentation_content)
        
        print(f"Documentation generated by {self.name} and written to README.md.")
        self.learn(task, "success")
        return "success"

class DeploymentAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Deployment AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "deployment"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is deploying the project...")

        # Real-world deployment: Building a Docker image
        result = subprocess.run(["docker", "build", "-t", "real_project_image", "."], capture_output=True)
        
        if result.returncode == 0:
            print("Docker image built successfully.")
            self.learn(task, "success")
            return "success"
        else:
            print(f"Failed to build Docker image:\n{result.stderr.decode()}")
            self.learn(task, "failure")
            return "failure"

class SecurityAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Security AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "security audit"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is performing a security audit...")
        
        # Real-world security audit: Checking dependencies
        result = subprocess.run(["pip", "audit"], capture_output=True)
        
        if result.returncode == 0:
            print("Security audit passed. No vulnerabilities found.")
            self.learn(task, "success")
            return "success"
        else:
            print(f"Vulnerabilities detected:\n{result.stdout.decode()}")
            self.learn(task, "failure")
            return "failure"



class DatabaseAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Database AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "database setup"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is setting up the database...")

        # Real-world database setup: Create SQLite database
        db_path = "./real_project/db/project.db"
        conn = sqlite3.connect(db_path)
        cursor = conn.cursor()

        # Create example table
        cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER PRIMARY KEY,
            username TEXT NOT NULL,
            email TEXT NOT NULL UNIQUE
        )
        ''')
        conn.commit()
        conn.close()
        
        print(f"Database created by {self.name}.")
        self.learn(task, "success")
        return "success"


class LoggingAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Logging AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "logging setup"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is setting up logging for the project...")

        # Set up real-world logging using Python's logging module
        logging.basicConfig(
            filename='./real_project/logs/project.log',
            level=logging.DEBUG,
            format='%(asctime)s %(levelname)s:%(message)s'
        )
        
        logging.info("Project log setup complete.")
        print(f"Logging setup complete by {self.name}.")
        self.learn(task, "success")
        return "success"

class VersionControlAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Version Control AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "version control"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is setting up version control...")

        # Real-world Git setup: Initialize a Git repository and make an initial commit
        result = subprocess.run(["git", "init", "./real_project"], capture_output=True)
        
        if result.returncode == 0:
            subprocess.run(["git", "-C", "./real_project", "add", "."], capture_output=True)
            subprocess.run(["git", "-C", "./real_project", "commit", "-m", "Initial commit"], capture_output=True)
            print(f"Git repository initialized and initial commit made by {self.name}.")
            self.learn(task, "success")
            return "success"
        else:
            print(f"Failed to initialize Git repository:\n{result.stderr.decode()}")
            self.learn(task, "failure")
            return "failure"

class FrontendGeneratorAI(BaseAgent):
    def __init__(self, knowledge_base):
        super().__init__("Frontend Generator AI", knowledge_base)
    
    def can_handle(self, task):
        return task == "frontend generation"
    
    def execute_task(self, task):
        self.adjust_behavior(task)
        print(f"{self.name} is generating frontend for the project...")

        # Real-world frontend generation: Create a simple HTML/CSS/JS project
        base_path = "./real_project/frontend/"
        os.makedirs(base_path, exist_ok=True)
        
        html_content = """
            <!DOCTYPE html>
            <html lang="en">
            <head>
                <meta charset="UTF-8">
                <meta name="viewport" content="width=device-width, initial-scale=1.0">
                <title>My Project</title>
                <link rel="stylesheet" href="styles.css">
            </head>
            <body>
                <h1>Welcome to My Project</h1>
                <script src="app.js"></script>
            </body>
            </html>
            """
        css_content = """
            body {
                font-family: Arial, sans-serif;
                background-color: #f4f4f4;
            }
            """
        js_content = """
            document.addEventListener('DOMContentLoaded', function() {
                console.log('Frontend is ready!');
            });
            """
        with open(os.path.join(base_path, "index.html"), 'w') as f:
            f.write(html_content)
        
        with open(os.path.join(base_path, "styles.css"), 'w') as f:
            f.write(css_content)
        
        with open(os.path.join(base_path, "app.js"), 'w') as f:
            f.write(js_content)
        
        print(f"Frontend generated by {self.name}.")
        self.learn(task, "success")
        return "success"

